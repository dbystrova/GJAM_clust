2*2*diag(rgamma(r,shape=1,rate=0.001))))
otherpar$K <- sample(1:N,length(notOther),replace=T)
if(DRtype=="basic"){ otherpar$alpha.DP <- alpha.DP
otherpar$pvec     <- .sampleP(N=N, avec=rep(alpha.DP/N,(N-1)),
bvec=((N-1):1)*alpha.DP/N, K=otherpar$K)
}
if(DRtype=="1")  {otherpar$alpha.DP <- alpha.DP #initial point for alpha
otherpar$alpha.DP_vec=alpha.DP
otherpar$alpha.DP <- alpha.DP
otherpar$pvec<- .sampleP(N=N, avec=rep(alpha.DP/N,(N-1)),
bvec=((N-1):1)*alpha.DP/N, K=otherpar$K)
otherpar$rate<-rate
otherpar$shape<-shape
alpha.DP_g<-rep(0,ng)
pk_g<-matrix(1,ng,N)
}
if(DRtype=="2")  {
otherpar$discount.PY <-discount.PY
otherpar$alpha.PY <- alpha.PY
otherpar$pvec      <-  .sampleP_PYM(N = N, alpha_val = alpha.PY, sigma_val = discount.PY, K = otherpar$K, Mat =Precomp_matrix,  func = ptr_logv_comp_mat)
otherpar$matrixCnk <- Precomp_matrix
otherpar$fun_pointer <- ptr_logv_comp_mat
pk_g<-matrix(1,ng,N)
}
if(DRtype=="3")  {
otherpar$discount.PY <-discount.PY
otherpar$alpha.PY <- alpha.PY
otherpar$pvec     <- .sampleP(N=N, avec=rep(1-discount.PY,(N-1)),
bvec=(1:(N-1))*discount.PY + alpha.PY, K=otherpar$K)
pk_g<-matrix(1,ng,N)
}
kgibbs <- matrix(1,ng,S)
sgibbs <- matrix(0,ng, N*r)
nnames <- paste('N',1:N,sep='-')
rnames <- paste('r',1:r,sep='-')
colnames(sgibbs) <- .multivarChainNames(nnames,rnames)
sigErrGibbs <- rep(0,ng)
rndEff <- w*0
} else {
Kindex <- which(as.vector(lower.tri(diag(S),diag=T)))
nK     <- length(Kindex)
sgibbs <- matrix(0,ng,nK)
colnames(sgibbs) <- .multivarChainNames(snames,snames)[Kindex] # half matrix
}
out <- .param.fn(CLUST=T, x, beta = bg[,notOther], Y = w[,notOther], otherpar)
out
.sampleP_PYM <- function(N, alpha_val, sigma_val, K, Mat, func){
n_k<- table(K)
lh<-  rep(0,N)
alpha= alpha_val
sigma=sigma_val
#sample v
ptr_logv_comp_mat <- create_xptr("log_v_pdf_comp_mat")
v_s = ru_rcpp(logf = func,alpha=alpha, sigma=sigma,H=N,k = length(n_k), nk_vec=n_k,Cnk_mat=Mat, n=1,  d=1, init=1)
#sample lk
lk <- sample_lk_mat(n_k,v_s$sim_vals[1],sigma,N,Mat)
lh[c(as.numeric(c(names(n_k))))]= lk
vh <- rep(0,N)  # initialize
W_h <- rep(0,N)
P_h<-  rep(0,N)
p_vec<- n_k - lk*sigma
W_h<- rdirichlet(1,c(p_vec, sum(lk)*sigma + alpha))
### R
alpha_post<- alpha + sum(lk)*sigma
Uv<- rgamma(1,alpha_post/sigma,alpha_post/sigma)
U<- (Uv)^(1/sigma)
x.rlap <- rlaptrans(N, lt.temp_st_pdf, c=alpha_post/(sigma*N), sigma, k=U)
R_h<- x.rlap /sum(x.rlap)
P_h[c(as.numeric(c(names(n_k))))]<- W_h[1:length(n_k)] + W_h[length(n_k)]* R_h[1:length(n_k)]
P_h[-c(as.numeric(c(names(n_k))))] <-  W_h[length(n_k)]* R_h[(length(n_k)+1):N]
print("1")
return(P_h)
}
out <- .param.fn(CLUST=T, x, beta = bg[,notOther], Y = w[,notOther], otherpar)
##################################################################################################
# PY_SB
rl3   <- list(r = r_reduct, DRtype="3" ,sigma_py=0.25,K=K_prior)
ml3   <- list(ng = iterations, burnin = burn_period, typeNames = 'PA', reductList = rl3,PREDICTX = F)
modelList = ml3
holdoutN      <-  0
holdoutIndex  <- numeric(0)
modelSummary  <- betaPrior  <- traitList <- effort <- NULL
specByTrait   <- traitTypes <- breakList <- notStandard <- NULL
censor <- censorCA <- censorDA <- CCgroups <- FCgroups <- intMat <- NULL
reductList <- y0 <- N  <- r <- otherpar <- pg <- NULL
ng     <- 2000
burnin <- 500
REDUCT <- TRAITS <- FULL <- F
PREDICTX <- T
lambdaPrior <- betaPrior <- NULL
RANDOM <- F              # random group intercepts
TIME <- F
timeList <- timeZero <- timeLast <- timeIndex <- groupIndex <-
rowInserts <- Lmat <- Amat <- beta <- NULL
ematAlpha <- .5
#alpha.DP <- ncol(ydata)          # not needed
#if(alpha.DP == 1) #no more correct now
if(ncol(ydata) == 1)
stop('multivariate model: at least 2 columns needed in ydata')
for(k in 1:length(modelList))assign( names(modelList)[k], modelList[[k]] )
if('CCgroups' %in% names(modelList))attr(typeNames,'CCgroups')  <- CCgroups
if('FCgroups' %in% names(modelList))attr(typeNames,'FCgroups')  <- FCgroups
if('CATgroups' %in% names(modelList))attr(typeNames,'CATgroups') <- CATgroups
if(!is.null(timeList)){
if("betaPrior" %in% names(timeList)){
colnames(timeList$betaPrior$lo) <-
colnames(timeList$betaPrior$hi) <-
.cleanNames(colnames(timeList$betaPrior$lo))
}
if("lambdaPrior" %in% names(timeList)){
colnames(timeList$lambdaPrior$lo) <- colnames(timeList$lambdaPrior$hi) <-
.cleanNames(colnames(timeList$lambdaPrior$lo))
}
for(k in 1:length(timeList))assign( names(timeList)[k], timeList[[k]] )
TIME <- T
REDUCT <- T
BPRIOR <- T
holdoutN      <-  0
holdoutIndex  <- numeric(0)
}
if(!is.null(traitList)){
TRAITS <- T
for(k in 1:length(traitList))assign( names(traitList)[k], traitList[[k]] )
stt <- .replaceString(colnames(specByTrait),'_','')
colnames(specByTrait) <- stt
colnames(plotByTrait) <- stt
colnames(traitList$specByTrait) <- stt
colnames(traitList$plotByTrait) <- stt
modelList$traitList <- traitList
}
if(burnin >= ng) stop( 'burnin must be < no. MCMC steps, ng' )
if('censor' %in% names(modelList)){
for(k in 1:length(censor)){
if( nrow(censor[[k]]$partition) != 3 )
stop('censor matrix: 3 rows for value, lo, hi')
rownames(censor[[k]]$partition) <- c('value','lo','hi')
}
}
if(missing(xdata)) xdata <- environment(formula)
S <- ncol(ydata)
if(length(typeNames) == 1)typeNames <- rep(typeNames,S)
if(length(typeNames) != S)
stop('typeNames must be one value or no. columns in y')
############### factors in y
tmp <- .checkYfactor(ydata, typeNames)
ydata <- tmp$ydata; yordNames <- tmp$yordNames
if(TRAITS){
if(!all( typeNames %in% c('CC','FC') ) )
stop('trait prediction requires composition data (CC or FC)')
if(nrow(plotByTrait) != nrow(ydata))
stop('nrow(plotByTrait) must equal nrow(ydata)')
if(ncol(plotByTrait) != length(traitTypes))
stop('ncol(plotByTrait) must equal length(traitTypes)')
if(ncol(plotByTrait) != length(traitTypes))
stop('ncol(plotByTrait) must equal length(traitTypes)')
ii <- identical(rownames(specByTrait),colnames(ydata))
if(!ii){
ww <- match(colnames(ydata),rownames(specByTrait) )
if( is.finite(min(ww)) ){
specByTrait <- specByTrait[ww,]
} else {
stop( 'rownames(specByTrait) must match colnames(ydata)' )
}
}
if(typeNames[1] == 'CC'){
ytmp <- round(ydata,0)
ytmp[ytmp == 0 & ydata > 0] <- 1
ydata <- ytmp
rm(ytmp)
}
}
tmp <- .buildYdata(ydata, typeNames)
y   <- tmp$y
ydataNames <- tmp$ydataNames
typeNames  <- tmp$typeNames
CCgroups   <- tmp$CCgroups
FCgroups   <- tmp$FCgroups
CATgroups  <- tmp$CATgroups
if(TRAITS) rownames(specByTrait) <- colnames(y)
S <- ncol(y)
n <- nrow(y)
cat("\nObservations and responses:\n")
print(c(n, S))
tmp    <- .buildEffort(y, effort, typeNames)
effort <- tmp
effMat <- effort$values
modelList$effort <- effort
re <- floor( diff( range(log10(effMat),na.rm=T) ) )
if(re > 2)
message(paste('sample effort > ', re, ' orders of magnitude--consider units near 1',sep='') )
tmp      <- .gjamGetTypes(typeNames)
typeCols <- tmp$typeCols
typeFull <- tmp$typeFull
typeCode <- tmp$TYPES[typeCols]
allTypes <- sort(unique(typeCols))
tmp <- .gjamXY(formula, xdata, y, typeNames, notStandard)
x      <- tmp$x; y <- tmp$y; snames <- tmp$snames
xdata  <- tmp$xdata; xnames <- tmp$xnames
interBeta   <- tmp$interaction
factorBeta  <- tmp$factorAll
designTable <- tmp$designTable;    xscale <- tmp$xscale
predXcols   <- tmp$predXcols
standMat    <- tmp$standMat;      standMu <- tmp$standMu
standRows   <- tmp$standRows;
xdataNames  <- tmp$xdataNames
notStandard <- tmp$notStandard[tmp$notStandard %in% xnames]
factorLambda <- interLambda <- NULL
if(!is.null(lambdaPrior)){
lformula <- attr(lambdaPrior$lo,'formula')
tmp <- .gjamXY(lformula, xdata, y, typeNames, notStandard)
xl   <- tmp$x
mm <- match(colnames(xl),colnames(xdata))
wm <- which(is.finite(mm))
if(length(wm) > 0){
xdata[,mm[wm]] <- xl[,wm]
}
xlnames <- tmp$xnames
interLambda   <- tmp$interaction
factorLambda <- tmp$factorAll
designTable <- list(beta = designTable, lambda = tmp$designTable)
standMatL    <- tmp$standMat;      standMuL <- tmp$standMu
standRowsL    <- tmp$standRows;
notStandardL <- tmp$notStandard[tmp$notStandard %in% xlnames]
}
modelList     <- append(modelList, list('formula' = formula,
'notStandard' = notStandard))
Q <- ncol(x)
tmp <- .gjamMissingValues(x, y, factorBeta$factorList, typeNames)
xmiss  <- tmp$xmiss;   xbound <- tmp$xbound;
ymiss  <- tmp$ymiss;   missY <- tmp$missY
xprior <- tmp$xprior;  yprior <- tmp$yprior
nmiss  <- nrow(xmiss); mmiss  <- nrow(ymiss)
x  <- tmp$x; y <- tmp$y
if(TIME){
tmp <- .gjamMissingValues(xl, y, factorLambda$factorList, typeNames)
xlmiss  <- tmp$xmiss;   xlbound <- tmp$xbound;
xlprior <- tmp$xprior
nlmiss  <- nrow(xmiss)
xl <- tmp$x
}
reductList <- .setupReduct(modelList, S, Q, n) ##########
N <- reductList$N; r <- reductList$r ; K_pr <-  reductList$K;
PY_var <- reductList$V
DRtype <- reductList$DRtype
if(is.null(DRtype)){DRtype<-"basic"
alpha.DP <- S
}else{
if(!(DRtype %in% c("1","2","3"))){stop("The type of dimension reduction is not valid")}
}
if((!is.null(PY_var)&&!DRtype %in% c("3"))){
stop("Variance specified only for fixed PY")
}
## change for prior K(for "basic" no K assumed)
if(is.null(K_pr)&(DRtype %in% c("1","2","3"))){stop("Prior number of groups not specified, if you don't need the prior information choose basic version")}
## Change parameters for Ga(shape, rate)
if(DRtype=="1") {
gamma_pars<- compute_gamma_parameters(fun=function(x) simulatuion_function_DPM(x,funct=functionDPM,ns=30000,Sn=S,N_tr = N), K=K_pr)
rate <- gamma_pars$nu2
shape <-gamma_pars$nu1
alpha.DP <- 1
cat(c(rate,shape),"\n rate and shape \n")
}
if(DRtype=="2") {
discount.PY<-reductList$sigma_py;
alpha.PY<-reductList$alpha_py;
N<- reductList$N
Precomp_matrix <- reductList$Precomp_mat
cat(c(alpha.PY,discount.PY),"\n alpha and sigma \n")
ptr_logv_comp_mat <- create_xptr("log_v_pdf_comp_mat")
}
if(DRtype=="3") {
if(!(is.null(PY_var))) {
py_params <-  compute_fixed_parameters_PY_2d(K_pr,PY_var,S)
sigma_py<-py_params$sigma
alpha.DP<-py_params$alpha
} else{
discount.PY<-reductList$sigma_py
# alpha.DP<-compute_fixed_parameters_1d(fun= function(x) functionPY(x, S,sigma_py=sigma_py),K=K_pr)
alpha.PY<- compute_parameters_SB_1d(K_pr,S,S,10^4)
}
N_eps<-floor(.compute_tau_mean(discount.PY,alpha.PY,0.1) + 2*.compute_tau_var(discount.PY,alpha.PY,0.1))
N<- max(N_eps,30)
if (N <= S){
N=S}
reductList$N<- N
cat(c(alpha.PY,discount.PY),"\n alpha and sigma \n")
}
#the last values of the parameters are the starting points of the chains (for DRtype 1)
if(!is.null(reductList$N))REDUCT <- T
tmp <- .gjamHoldoutSetup(holdoutIndex, holdoutN, n)
holdoutIndex <- tmp$holdoutIndex; holdoutN <- tmp$holdoutN
inSamples    <- tmp$inSamples;         nIn <- tmp$nIn
tmp <- .gjamSetup(typeNames, x, y, breakList, holdoutN, holdoutIndex,
censor=censor, effort=effort)
w <- tmp$w; z <- tmp$z; y <- tmp$y; other <- tmp$other; cuts <- tmp$cuts
cutLo       <- tmp$cutLo; cutHi <- tmp$cutHi; plo <- tmp$plo; phi <- tmp$phi
ordCols     <- tmp$ordCols; disCols <- tmp$disCols; compCols <- tmp$compCols
conCols     <- which(typeNames == 'CON')
classBySpec <- tmp$classBySpec; breakMat <- tmp$breakMat
minOrd      <- tmp$minOrd; maxOrd <- tmp$maxOrd; censorCA <- tmp$censorCA
censorDA    <- tmp$censorDA; censorCON <- tmp$censorCON;
ncut <- ncol(cuts);  corCols <- tmp$corCols
catCols     <- which(attr(typeNames,'CATgroups') > 0)
sampleW     <- tmp$sampleW
ordShift    <- tmp$ordShift
sampleW[censorCA] <- 1
sampleW[censorDA] <- 1
sampleW[censorCON] <- 1
sampleWhold <- tgHold <- NULL
wHold <- NULL
wmax  <- apply(y/effMat,2,max,na.rm=T)
pmin  <- -2*abs(wmax)
if(mmiss > 0){
phi[ ymiss ] <- wmax[ ymiss[,2] ]
plo[ ymiss ] <- pmin[ ymiss[,2] ]
sampleW[ ymiss ] <- 1
}
ploHold <- phiHold <- NULL
if(holdoutN > 0){
sampleWhold <- sampleW[holdoutIndex,]  #to predict X
sampleW[holdoutIndex,] <- 1
tgHold  <- cuts
wHold   <- w[drop=F,holdoutIndex,]
ploHold <- plo[drop=F,holdoutIndex,]   # if LOHI: updated to current yp
phiHold <- phi[drop=F,holdoutIndex,]
}
byCol <- byRow <- F
if(attr(sampleW,'type') == 'cols')byCol <- T
if(attr(sampleW,'type') == 'rows')byRow <- T
indexW <- attr(sampleW,'index')
notCorCols <- c(1:S)
if(length(corCols) > 0)notCorCols <- notCorCols[-corCols]
############ 'other' columns
sigmaDf  <- nIn - Q + S - 1
sg <- diag(.1,S)
SO <- S
notOther <- c(1:S)
sgOther  <- NULL
if(length(other) > 0){
notOther   <- notOther[!notOther %in% other]
SO         <- length(notOther)
sg[other,] <- sg[,other] <- 0
sgOther    <- matrix( cbind(other,other),ncol=2 )
sg[sgOther] <- .1
}
loB <- hiB <- NULL
beta <- bg <- matrix(0,Q,S)
rownames(beta) <- colnames(x)
BPRIOR <- F
if( !is.null(betaPrior) ){
colnames(betaPrior$lo) <- .cleanNames(colnames(betaPrior$lo))
colnames(betaPrior$hi) <- .cleanNames(colnames(betaPrior$hi))
loB <- betaPrior$lo
hiB <- betaPrior$hi
bg <- (loB + hiB)/2
bg[is.nan(bg)] <- 0
wB <- which(!is.na(t(loB[,notOther])), arr.ind=T)[,c(2,1)]
wB <- rbind(wB, which(!is.na(t(hiB[,notOther])), arr.ind=T)[,c(2,1)])
colnames(wB) <- c('row','col')
tmp <- .betaPrior(bg, notOther, loB, hiB)
bg <- tmp$beta; loB <- tmp$loB; hiB <- tmp$hiB
wB <- tmp$wB; BPRIOR <- tmp$BPRIOR
bg[is.nan(bg)] <- 0
tmp <- .getPattern(bg[,notOther], wB)
Brows <- tmp$rows
Bpattern <- tmp$pattern
BPRIOR <- T
bg[!is.finite(bg)] <- 0
}
zeroBeta <- .factorCoeffs2Zero(factorBeta, snames, betaPrior)  # max zero is missing factor level
zeroLambda <- NULL
if( TIME ){
BPRIOR <- T
tmp <- .getTimeIndex(timeList, other, notOther, xdata, x, xl, y, w)
Lmat   <- tmp$Lmat; Lpattern <- tmp$Lpattern;  wL <- tmp$wL
Vmat   <- tmp$Vmat;    Lrows <- tmp$Lrows; gindex <- tmp$gindex
loLmat <- tmp$loLmat; hiLmat <- tmp$hiLmat; Arows <- tmp$Arows
Amat   <- tmp$Amat; Apattern <- tmp$Apattern; wA <- tmp$wA
Umat   <- tmp$Umat;   uindex <- tmp$uindex
loAmat <- tmp$loAmat; hiAmat <- tmp$hiAmat; aindex <- tmp$aindex
Brows  <- tmp$Brows;      bg <- tmp$bg; Bpattern <- tmp$Bpattern
wB     <- tmp$wB;        loB <- tmp$loB; hiB <- tmp$hiB
timeZero <- tmp$timeZero; timeLast <- tmp$timeLast
maxTime  <- tmp$maxTime; inSamples <- tmp$inSamples
tindex   <- tmp$tindex; sindex <- tmp$sindex; i1 <- tmp$i1; i2 <- tmp$i2
if(is.null(loB))BPRIOR <- F
Unew <- Umat
Vnew <- Vmat
mua  <- mub <- mug <- muw <- w*0
zeroLambda <- .factorCoeffs2Zero(factorLambda, snames, lambdaPrior)
timeList$lambdaPrior$hi[zeroLambda] <- lambdaPrior$hi[zeroLambda] <- 0
timeList$betaPrior$hi[zeroBeta]     <- betaPrior$hi[zeroBeta] <- 0
standMatLmat <- Lmat*0
notStandardLmat <- numeric(0)
if(length(standRowsL) > 0){
csl <- paste('_',names(standRowsL),sep='')
for(j in 1:length(csl)){
wj <- grep(csl[j],rownames(Lmat))
standMatLmat[wj,] <- standMatL[standRowsL[j],]
notStandardLmat <- c(notStandardLmat,wj)
}
}
}
if(byCol){
inw <- intersect( colnames(y)[indexW], colnames(y)[notOther] )
indexW <- match(inw,colnames(y)[notOther])
}
IXX <- NULL
if(nmiss == 0){
XX    <- crossprod(x)
IXX <- chol2inv(chol( XX ) )
}
updateBeta <- .betaWrapper(REDUCT, TIME, BPRIOR, notOther, IXX,
betaLim=max(wmax)/2)
############ dimension reduction
inSamp <- inSamples
if(TIME)inSamp <- tindex[,1]     # index for x
CLUST <- T   # dirichlet
if(DRtype=="basic") .param.fn <- .paramWrapper(REDUCT, inSamp, SS=length(notOther))
if(DRtype=="1") .param.fn <- .paramWrapper_1(REDUCT, inSamp, SS=length(notOther))
if(DRtype=="2") .param.fn <- .paramWrapper_2(REDUCT, inSamp, SS=length(notOther))
if(DRtype=="3") .param.fn <- .paramWrapper_3(REDUCT, inSamp, SS=length(notOther))
.param.fn
sigmaerror <- .1
if(DRtype=="basic")  otherpar   <- list(S = S, Q = Q, sigmaerror = sigmaerror,
Z = NA, K =rep(1,S), sigmaDf = sigmaDf)
if(DRtype=="1")  otherpar   <- list(S = S, Q = Q, sigmaerror = sigmaerror,
Z = NA, K =rep(1,S), sigmaDf = sigmaDf,alpha.DP=alpha.DP,rate=rate,shape=shape, alpha.DP_vec=alpha.DP)
if(DRtype=="2") otherpar   <- list(S = S, Q = Q, sigmaerror = sigmaerror,
Z = NA, K =rep(1,S), sigmaDf = sigmaDf,alpha.PY=alpha.PY,discount.PY=discount.PY, matrixCnk = Precomp_matrix, fun_pointer = ptr_logv_comp_mat)
if(DRtype=="3")  otherpar   <- list(S = S, Q = Q, sigmaerror = sigmaerror,
Z = NA, K =rep(1,S), sigmaDf = sigmaDf,alpha.PY=alpha.PY,discount.PY=discount.PY)
otherpar
sigErrGibbs <- rndEff <- NULL
yp <- y
wmax <- ymax <- apply(y,2,max)
wmax <- wmax/effMat
if(REDUCT){
cat( paste('\nDimension reduced from',S,'X',S,'->',N,'X',r,'responses\n') )
otherpar$N <- N; otherpar$r <- r; otherpar$sigmaerror <- 0.1
otherpar$Z <- rmvnormRcpp(N,rep(0,r),1/S*diag(r))
otherpar$D <- .riwish(df = (2 + r + N),
S = (crossprod(otherpar$Z) +
2*2*diag(rgamma(r,shape=1,rate=0.001))))
otherpar$K <- sample(1:N,length(notOther),replace=T)
if(DRtype=="basic"){ otherpar$alpha.DP <- alpha.DP
otherpar$pvec     <- .sampleP(N=N, avec=rep(alpha.DP/N,(N-1)),
bvec=((N-1):1)*alpha.DP/N, K=otherpar$K)
}
if(DRtype=="1")  {otherpar$alpha.DP <- alpha.DP #initial point for alpha
otherpar$alpha.DP_vec=alpha.DP
otherpar$alpha.DP <- alpha.DP
otherpar$pvec<- .sampleP(N=N, avec=rep(alpha.DP/N,(N-1)),
bvec=((N-1):1)*alpha.DP/N, K=otherpar$K)
otherpar$rate<-rate
otherpar$shape<-shape
alpha.DP_g<-rep(0,ng)
pk_g<-matrix(1,ng,N)
}
if(DRtype=="2")  {
otherpar$discount.PY <-discount.PY
otherpar$alpha.PY <- alpha.PY
otherpar$pvec      <-  .sampleP_PYM(N = N, alpha_val = alpha.PY, sigma_val = discount.PY, K = otherpar$K, Mat =Precomp_matrix,  func = ptr_logv_comp_mat)
otherpar$matrixCnk <- Precomp_matrix
otherpar$fun_pointer <- ptr_logv_comp_mat
pk_g<-matrix(1,ng,N)
}
if(DRtype=="3")  {
otherpar$discount.PY <-discount.PY
otherpar$alpha.PY <- alpha.PY
otherpar$pvec     <- .sampleP(N=N, avec=rep(1-discount.PY,(N-1)),
bvec=(1:(N-1))*discount.PY + alpha.PY, K=otherpar$K)
pk_g<-matrix(1,ng,N)
}
kgibbs <- matrix(1,ng,S)
sgibbs <- matrix(0,ng, N*r)
nnames <- paste('N',1:N,sep='-')
rnames <- paste('r',1:r,sep='-')
colnames(sgibbs) <- .multivarChainNames(nnames,rnames)
sigErrGibbs <- rep(0,ng)
rndEff <- w*0
} else {
Kindex <- which(as.vector(lower.tri(diag(S),diag=T)))
nK     <- length(Kindex)
sgibbs <- matrix(0,ng,nK)
colnames(sgibbs) <- .multivarChainNames(snames,snames)[Kindex] # half matrix
}
otherpar
out <- .param.fn(CLUST=T, x, beta = bg[,notOther], Y = w[,notOther], otherpar)
out
tibble(it= 1: length(apply(fit_gjam$chains$kgibbs,1,function(x) length(unique(x)))),
DP= apply(fit_gjam$chains$kgibbs,1,function(x) length(unique(x))),
DP1 =apply(fit_gjamDP1$chains$kgibbs,1,function(x) length(unique(x))),
PY1=apply(fit_gjamPY1$chains$kgibbs,1,function(x) length(unique(x))),
PY2=apply(fit_gjamPY2$chains$kgibbs,1,function(x) length(unique(x)))
) %>%
gather(Model, trace, DP:PY2)%>%
ggplot(aes(x=it,y=trace,col=Model))+geom_line(alpha=0.7)+ scale_color_viridis(discrete=TRUE)+
labs(title="Traceplots of the posterior of the number of clusters")+xlab("iterations")+ylab("Number of clusters") +theme_bw()+geom_hline(yintercept = 16,color = "red")+
theme(axis.text.x = element_text(angle = 0, hjust = 1,size = 10), strip.text = element_text(size = 15),legend.position = "top", plot.title = element_text(hjust = 0.5))+
theme(axis.text.x = element_text(size = 14), axis.title.x = element_text(size = 16),
axis.text.y = element_text(size = 14), axis.title.y = element_text(size = 16),
plot.title = element_text(size = 20)) +theme(legend.text=element_text(size=15))
plot(1:50000, apply(fit_gjamPY1$chains$kgibbs,1,function(x) length(unique(x))),)
plot(1:50000, apply(fit_gjamPY2$chains$kgibbs,1,function(x) length(unique(x))),)
plot(1:50000, apply(fit_gjamPY2$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamPY1$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamPY2$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamDP2$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamDP1$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamPY1$chains$kgibbs,1,function(x) length(unique(x))))
plot(1:50000, apply(fit_gjamPY2$chains$kgibbs,1,function(x) length(unique(x))))
